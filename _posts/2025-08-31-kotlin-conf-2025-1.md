---
title: "2025 Kotlin Conf (1)"
subtitle: "Dissecting Kotlin: Surveying the Latest Stable and Experimental"
date: 2025-08-31 19:00:00 +09:00
last_modified_at: 2025-08-31 23:00:00 +09:00
categories: [ Programming, Kotlin ]
tags:
  [
    kotlin,
    코틀린,
    Conf,
    Conference,
    컨퍼런스,
    Jetbrains
  ]
image: "/assets/img/posts/jetbrains-logo.png"
---

> 코틀린 2025 컨퍼런스 세션을 하나씩 보면서 정리해보는 시간을 갖고자 한다. 코틀린 관련 자료 중 한글로 된 문서가
> 워낙 없기도 하고 스스로 최신 코틀린 트렌드를 따라갈겸 정리해서 틈틈이 업로드 하고자 한다.

## Enum class - `values()` vs `entries`

### 배경

어느 순간부터 enum class에서 `values()`를 호출하게 되면 아래와 같은 경고가 나타난다.

```text
'Enum.values()' is recommended to be replaced by 'Enum.entries' since 1.9
```

Kotlin 1.9부터 `entries`를 사용하는 것을 권장하는데, 두 메서드의 차이점을 자세히 알아보자.

### `values()` 메서드의 문제점

`values()` 메서드는 `Array<Enum>`을 반환하고 **가변(mutable)**이기 때문에 setter가 가능하다는 문제가 있다. 이렇게 쓸일은 사실 거의 없긴하다;;

```kotlin
enum class ShowCategory {
  SliceOfLife,
  Isekai,
  Mecha,
  Sports,
  Shonen
}

val values = ShowCategory.values()
values.set(0, ShowCategory.Shonen)
println("Available shows (as array): $values -> ${values.joinToString()}")
```

```text
출력: Available shows (as array): [LShowCategory;@7b23ec81 -> Shonen, Isekai, Mecha, Sports, Shonen
```

### `entries`의 장점

`entries`는 `EnumEntries<Enum>`를 반환한다. 소스코드를 살펴보면:
```kotlin
@SinceKotlin("1.9")
@WasExperimental(ExperimentalStdlibApi::class)
public sealed interface EnumEntries<E : Enum<E>> : List<E>
```
**sealed interface**로 `List`를 상속한다. 즉, **불변(immutable)**이다! setter가 없으며 내부 값을 수정할 수 없다.

### 왜 `List<E>`이고 왜 `sealed`일까?

발표자에 따르면:

1. **Context 유지**  
   단순 `List`가 아닌 `EnumEntries`로 감싸서 전달하면 해당 리스트의 **맥락(context)**을 유지할 수 있다.  
   _(First Class Collection과 유사한 개념일지도?)_

2. **Sealed Interface의 이점**  
   - 계층 구조를 명확히 표현
   - 같은 모듈 내에서 모든 경우의 수를 반드시 구현하는 **강제성** 확보

## Receiver

### Receiver란 무엇인가?
> **"Every function or property that is defined as a method or an extension has one or more special parameters called *receiver* parameters."**

**번역**  
> "메서드나 확장 함수로 정의된 모든 함수 또는 프로퍼티는 *리시버(receiver)* 파라미터라고 불리는 하나 이상의 특별한 파라미터를 가지고 있다."

### 핵심 개념

Kotlin에서 함수가 호출될 때 그 함수가 작동할 **대상 객체**를 의미한다:

| 상황 | Receiver | 설명 |
|------|----------|------|
| 확장 함수 | `String` in `String.addExclamation()` | 확장 대상 타입 |
| 멤버 함수 | `this` | 암묵적 리시버 |
| 스코프 함수 | 람다의 수신 객체 | `with`, `apply` 등에서 사용 |

> 리시버는 함수 내부에서 `this`로 접근 가능하며, 종종 생략된다.

```kotlin
with(one) {
  this  // Implicit receiver `One`.
  println(value)

  two.run {
    this@with.value // Implicit receiver `One`.
    this // Implicit receiver `Two`
    println(value)

    three.apply {
      this@with.value // Implicit receiver `One`.
      println(this@run.value) // Implicit receiver `Two`.
      this // Implicit receiver `Three`
      println(value)
    }
  }
}
```

### 코드 분석

> scope function을 중첩해서 사용하는 것은 지양해야 하지만, 학습 목적으로 이런식으로 제공한듯 하다.

- `with(one)` → `this`는 `one`을 receiver로 받음
- `two.run` 내부의 `this@with.value` → 명시적으로 외부 scope의 `one`을 참조
- 기본적으로 가장 가까운 scope의 receiver가 우선순위를 가짐 

## Context in Scope Function

확장함수를 사용할 때 우리는 흔히 
```kotlin
val String?.isValidAccountNumber: Boolean
    get() = this != null && startsWith("ACCT") && length == 10
```
이런식으로 사용하곤 한다.
하지만 이런식으로 확장함수를 만들게 되면 프로젝트의 모든 곳에서 String의 확장함수로 해당 메소드를 호출하는 것이 가능해진다. 그렇게 되면 우리가 해당 함수를 사용할 사용처가 모호해지고 어떠한 맥락에서 사용해야할지 헷갈릴 수 있다.

```kotlin
interface Profile {
  /**
   * User-input account number.
   */
  val enteredAccount: String

  /**
   * Returns whether this String is formatted as a valid
   * account number.
   */
  val String?.isValidAccountNumber: Boolean
    get() = this != null && startsWith("ACCT") && length == 10
}
```

하지만 이런식으로 특정 class안에 해당 확장함수를 선언하게 된다면 
```kotlin
fun validateUserInfo(userProfile: Profile): Boolean {
  userProfile.enteredAccount.isValidAccountNumber
}
```

이런식으로는 접근할 수가 없게된다. context(맥락)이 없기 때문이다. 

```kotlin
fun validateUserInfo(userProfile: Profile): Boolean {
  return with(userProfile) {
    userProfile.enteredAccount.isValidAccountNumber
  }
}
```
반드시 선언된 class를 receiver로 사용해야만 해당 메소드에 접근이 가능해지게 된다.

## Context Receiver

```kotlin
context(UserRepository)
private val String?.isAccountNumber: Boolean
  get() = this != null && startsWith("ACCT") && length == 10
```

확장함수의 맥락을 이런식으로 선언해줄수도 있다고 한다.

## Context Parameters

```kotlin
context(client: Client, logger: Logger)
fun fetchStoreUser(id: Int): User {
  val user = client.fetchUser(id)
  logger.debug("Fetched user: $id")
  return user
}
```
확장함수의 receiver를 받아서 해당 값을 인자로 받을수도 있는듯하다.

```kotlin
context(_: Client, _: Logger)
fun loadScreen(
  id: Int,
  loader: DataLoader,
): User {
  return loader(id)
}

typealias DataLoader = context(Client, Logger) (Int) -> User
```


## 참고 자료

* [Kotlin Conf 2025 - Dissecting Kotlin: Surveying the Latest Stable and Experimental](https://www.youtube.com/watch?v=sDA28kH6AIc)
* [Kotlin 공식 문서](https://kotlinlang.org/docs/home.html)
* [KEEP (Kotlin Evolution and Enhancement Process)](https://github.com/Kotlin/KEEP)